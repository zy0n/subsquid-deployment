enum ActionType {
  CommitmentBatch
  GeneratedCommitmentBatch
  Shield
  Transact
  Nullifier
  Unshield
}

# Sync with TS enum in railgun-smart-wallet.ts
enum TokenType {
  ERC20
  ERC721
  ERC1155
}

type Token @entity {
  id: ID! # output of getTokenID()
  tokenType: TokenType!
  tokenAddress: Bytes! #address
  tokenSubID: ID!
}

type CommitmentBatchCiphertext @entity {
  id: ID! # TODO: decide id composition
  ciphertext: [BigInt!]!
  ephemeralKeys: [BigInt!]!
  memo: [BigInt!]!

}

type GeneratedCommitmentBatchCommitment @entity {
  id: ID! # TODO: decide id composition
  npk: BigInt!
  token: Token!
  value: BigInt!
}

# TODO: same as above, determine usefulness of separation.
type ShieldCommitment @entity {
  id: ID! # TODO: decide id composition
  npk: BigInt!
  token: Token!
  value: BigInt!
}

type ShieldCiphertext @entity {
  encryptedBundle: [BigInt!]!
  shieldKey: BigInt!
}

type TransactCiphertext @entity {
  id: ID! # TODO: decide id composition
  ciphertext: [BigInt!]!
  blindedSenderViewingKey: BigInt!
  blindedReceiverViewingKey: BigInt!
  annotationData: BigInt!
  memo: BigInt!
}

# Actions 
type CommitmentBatch @entity {
  id: ID! # TODO: decide id composition
  treeNumber: Int!
  startPosition: Int!
  hash: [BigInt!]!
  ciphertext: [CommitmentBatchCiphertext!]!

  # custom tagging
  actionType: ActionType!
}

type GeneratedCommitmentBatch @entity {
  id: ID! # TODO: decide id composition
  treeNumber: Int!
  startPosition: Int!
  commitments: [GeneratedCommitmentBatchCommitment!]!
  encryptedRandom: [[BigInt!]!]!

  # custom tagging
  actionType: ActionType!
}

type Shield @entity {
  id: ID! # TODO: decide id composition
  treeNumber: Int!
  startPosition: Int!
  commitments: [ShieldCommitment!]!
  shieldCiphertext: [ShieldCiphertext!]!

  # custom tagging
  actionType: ActionType!
}

# technically this 'event' trigger is the only 
# time transact is actually called... so in that. do we only need to
# reference the rgbatch rgtxid here?
type Transact @entity {
  id: ID! # TODO: decide id composition
  treeNumber: Int!
  startPosition: Int!
  hash: [BigInt!]!
  ciphertext: [TransactCiphertext!]!

  # custom tagging
  actionType: ActionType!

  #custom extra fields
  railgunBatchIndex: Int!
  railgunTxidIndex: Int!
}
}

type Nullifier @entity {
  id: ID! # TODO: decide id composition
  treeNumber: BigInt!
  nullifier: [BigInt!]! # TODO: check ability rename this (s)  

  # custom tagging
  actionType: ActionType!
}

type Unshield @entity {
  id: ID! # TODO: decide id composition
  npk: BigInt!
  token: Token!
  amount: BigInt!
  fee: BigInt!

  # custom tagging
  actionType: ActionType!
}

union RailgunAction = CommitmentBatch | GeneratedCommitmentBatch | Shield | Transact | Nullifier | Unshield

type EVMTransaction @entity {
  id: ID! # TODO: decide id composition
  transactionHash: Bytes!
  actions: [RailgunAction!]!
}

interface Action @query {
  id: ID! # TODO: decide id composition
  blockNumber: BigInt!
  blockTimestamp: BigInt!
  blockHash: Bytes!
  transactions: [EVMTransaction!]!
}